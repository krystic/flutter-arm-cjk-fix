#!/bin/bash

# --- 路径定义 ---
CONFIG_DIR="/etc/flutter-cjk"
CONFIG_FILE="$CONFIG_DIR/ubuntu.conf"
SERVICE_FILE="/etc/systemd/system/flutter-font-fix.service"
SCRIPT_PATH=$(realpath "$0")

# 自定义字体配置目录（与全局配置统一目录）
CUSTOM_FONT_CONFIG_DIR="$CONFIG_DIR"

# SO 文件版本检测和目录
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
SO_LIB_DIR="/usr/local/lib/flutter-cjk"
FLUTTER_HASH_VERSION_CACHE="$CONFIG_DIR/flutter.engine.hash.version"

# GitHub Raw CDN 前缀（可通过 --cdn 参数覆盖）
RAW_CDN_PREFIX="https://raw.githubusercontent.com/"
GITHUB_RAW_BASE="${RAW_CDN_PREFIX}krystic/flutter-arm-cjk-fix/main/lib"

NOTO_DIR="/usr/share/fonts/opentype/noto"
NOTO_REG="$NOTO_DIR/NotoSansCJK-Regular.ttc"
NOTO_BOLD="$NOTO_DIR/NotoSansCJK-Bold.ttc"
NOTO_LIGHT="$NOTO_DIR/NotoSansCJK-Light.ttc"
NOTO_MEDIUM="$NOTO_DIR/NotoSansCJK-Medium.ttc"

# --- 辅助函数 ---

# 统一的 Flutter 版本检测函数（通过 SO 文件 hash）
detect_flutter_version_from_so() {
    local app_path=$1
    
    # 1. 查找 libflutter_linux_gtk.so
    local so_path=$(find -L "$app_path" -name "libflutter_linux_gtk.so*" 2>/dev/null | head -n1)
    
    if [[ -z "$so_path" || ! -f "$so_path" ]]; then
        return 1
    fi
    
    # 2. 提取 hash
    local engine_hashes
    engine_hashes=$(extract_engine_hash_from_so "$so_path") || return 1
    
    # 3. 更新 hash-version 缓存
    update_flutter_hash_version_cache 2>/dev/null || true
    
    # 4. 查找匹配的版本
    local flutter_version=""
    
    while IFS= read -r hash; do
        [[ -z "$hash" ]] && continue
        flutter_version=$(find_flutter_version_by_hash "$hash" 2>/dev/null)
        if [[ $? -eq 0 && -n "$flutter_version" ]]; then
            echo "$flutter_version"
            return 0
        fi
    done <<< "$engine_hashes"
    
    return 1
}

# --- 非 Snap 应用支持函数 ---

# 从可执行文件获取 libflutter_linux_gtk.so 的路径
get_so_path_from_executable() {
    local exe_path=$1
    
    if [[ ! -x "$exe_path" ]]; then
        echo "[ERROR] Executable not found or not executable: $exe_path" >&2
        echo "        可执行文件不存在或无执行权限。" >&2
        return 1
    fi
    
    local so_path=$(ldd "$exe_path" 2>/dev/null | grep libflutter_linux_gtk.so | awk '{print $3}')
    
    if [[ -z "$so_path" ]]; then
        echo "[ERROR] libflutter_linux_gtk.so not found in executable dependencies" >&2
        echo "        未在可执行文件依赖中找到 libflutter_linux_gtk.so。" >&2
        return 1
    fi
    
    if [[ ! -f "$so_path" ]]; then
        echo "[ERROR] SO file path found but file doesn't exist: $so_path" >&2
        echo "        找到 SO 路径但文件不存在。" >&2
        return 1
    fi
    
    echo "$so_path"
    return 0
}

# 从 SO 文件提取 Flutter Engine hash（可能有多个）
extract_engine_hash_from_so() {
    local so_path=$1
    
    if [[ ! -f "$so_path" ]]; then
        echo "[ERROR] SO file not found: $so_path" >&2
        return 1
    fi
    
    local hashes=$(strings "$so_path" 2>/dev/null | grep -E "^[0-9a-f]{40}$")
    
    if [[ -z "$hashes" ]]; then
        echo "[ERROR] Could not extract engine hash from SO file" >&2
        echo "        无法从 SO 文件提取引擎 hash。" >&2
        return 1
    fi
    
    echo "$hashes"
    return 0
}

# 生成或更新 Flutter hash-version 对照表缓存
update_flutter_hash_version_cache() {
    mkdir -p "$CONFIG_DIR"
    
    # 如果缓存已存在且不是很旧（7天内），直接返回
    if [[ -f "$FLUTTER_HASH_VERSION_CACHE" ]]; then
        local cache_age=$(($(date +%s) - $(stat -c %Y "$FLUTTER_HASH_VERSION_CACHE" 2>/dev/null || echo 0)))
        if [[ $cache_age -lt 604800 ]]; then
            return 0
        fi
    fi
    
    echo "[INFO] Updating Flutter hash-version cache from GitHub..." >&2
    echo "       正在从 GitHub 更新 Flutter hash-version 对照表..." >&2
    
    # 使用与 test.hash.sh 相同的逻辑
    {
        git ls-remote --tags --refs https://github.com/flutter/flutter.git 2>/dev/null | \
            sed 's/refs\/tags\///' | \
            awk '{
                split($2, v, ".");
                if ($2 ~ /^[0-9]+\.[0-9]+\.[0-9]+$/) {
                    if (v[1] > 3 || (v[1] == 3 && v[2] > 27) || (v[1] == 3 && v[2] == 27 && v[3] >= 4)) {
                        print $1 " | " $2
                    }
                }
            }' | sort -V -r -k3
    } > "$FLUTTER_HASH_VERSION_CACHE"

    {
        git ls-remote --tags --refs https://github.com/flutter/engine.git 2>/dev/null | \
            sed 's/refs\/tags\///' | \
            awk '{if ($2 ~ /^[0-9]+\.[0-9]+\.[0-9]+$/) print $1 " | " $2}' | \
            sort -V -r -k3
    } >> "$FLUTTER_HASH_VERSION_CACHE"
    
    echo "[OK] Cache updated: $FLUTTER_HASH_VERSION_CACHE" >&2
    echo "     缓存已更新。" >&2
    return 0
}

# 从 hash 查找对应的 Flutter 版本
find_flutter_version_by_hash() {
    local hash=$1
    
    # 确保缓存存在
    if [[ ! -f "$FLUTTER_HASH_VERSION_CACHE" ]]; then
        update_flutter_hash_version_cache || return 1
    fi
    
    # 查找匹配的版本（可能有多个）
    local versions=$(grep "^$hash" "$FLUTTER_HASH_VERSION_CACHE" 2>/dev/null | awk -F' \\| ' '{print $2}')
    
    if [[ -z "$versions" ]]; then
        echo "[WARN] No matching Flutter version found for hash: $hash" >&2
        echo "       未找到匹配该 hash 的 Flutter 版本。" >&2
        return 1
    fi
    
    # 如果有多个版本，显示所有并让用户选择
    local version_array=()
    while IFS= read -r ver; do
        [[ -n "$ver" ]] && version_array+=("$ver")
    done <<< "$versions"
    
    if [[ ${#version_array[@]} -eq 0 ]]; then
        return 1
    elif [[ ${#version_array[@]} -eq 1 ]]; then
        echo "${version_array[0]}"
        return 0
    else
        echo "[INFO] Multiple versions found for hash $hash:" >&2
        echo "       找到多个匹配的版本：" >&2
        local i
        for ((i=0; i<${#version_array[@]}; i++)); do
            echo "  [$((i+1))] ${version_array[$i]}" >&2
        done
        echo "" >&2
        read -r -p "Select version number (选择版本编号) [1]: " choice
        choice=${choice:-1}
        
        if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#version_array[@]} )); then
            echo "${version_array[$((choice-1))]}"
            return 0
        else
            echo "[ERROR] Invalid selection" >&2
            echo "        选择无效。" >&2
            return 1
        fi
    fi
}

# 处理非 Snap 应用（通过可执行文件路径）
handle_executable_app() {
    local exe_path=$1
    
    echo ""
    echo "[INFO] Processing executable: $exe_path"
    echo "       正在处理可执行文件..."
    echo ""
    
    # 步骤 1: 获取 SO 文件路径
    echo "[1/5] Finding libflutter_linux_gtk.so..."
    echo "      正在查找 libflutter_linux_gtk.so..."
    local so_path
    so_path=$(get_so_path_from_executable "$exe_path") || return 1
    echo "      Found: $so_path"
    echo ""
    
    # 步骤 2: 提取 Engine hash
    echo "[2/5] Extracting Flutter Engine hash..."
    echo "      正在提取 Flutter Engine hash..."
    local engine_hashes
    engine_hashes=$(extract_engine_hash_from_so "$so_path") || return 1
    
    # 统计 hash 数量
    local hash_count=$(echo "$engine_hashes" | wc -l)
    echo "      Found $hash_count hash(es):"
    while IFS= read -r hash; do
        echo "        - $hash"
    done <<< "$engine_hashes"
    echo ""
    
    # 步骤 3: 更新 hash-version 缓存
    echo "[3/5] Updating hash-version cache..."
    echo "      正在更新 hash-version 对照表..."
    update_flutter_hash_version_cache || {
        echo "[WARN] Failed to update cache, will try with existing cache" >&2
        echo "       更新缓存失败，将使用现有缓存。" >&2
    }
    echo ""
    
    # 步骤 4: 查找对应的 Flutter 版本（逐个 hash 尝试）
    echo "[4/5] Finding Flutter version..."
    echo "      正在查找对应的 Flutter 版本..."
    local flutter_version=""
    local matched_hash=""
    
    while IFS= read -r hash; do
        [[ -z "$hash" ]] && continue
        echo "      Trying hash: $hash"
        flutter_version=$(find_flutter_version_by_hash "$hash" 2>/dev/null)
        if [[ $? -eq 0 && -n "$flutter_version" ]]; then
            matched_hash="$hash"
            break
        fi
    done <<< "$engine_hashes"
    
    if [[ -z "$flutter_version" ]]; then
        echo ""
        echo "[ERROR] Could not determine Flutter version for any hash" >&2
        echo "        无法为任何 hash 确定 Flutter 版本。" >&2
        echo ""
        echo "[INFO] Tried hashes:" >&2
        while IFS= read -r hash; do
            echo "       - $hash" >&2
        done <<< "$engine_hashes"
        echo ""
        echo "[INFO] You may need to compile Flutter Engine manually." >&2
        echo "       您可能需要手动编译 Flutter Engine。" >&2
        echo "       See: https://github.com/krystic/flutter-arm-cjk-fix/blob/main/README.md" >&2
        return 1
    fi
    
    echo "      Version: $flutter_version (matched hash: ${matched_hash:0:8}...)"
    echo ""
    
    # 步骤 5: 统一查找所有可用版本（精确+相似，本地+线上）
    echo "[5/5] Checking for available SO files..."
    echo "      正在检查可用的 SO 文件..."
    
    local all_versions
    all_versions=$(find_all_available_versions "$flutter_version")
    
    if [[ $? -ne 0 || -z "$all_versions" ]]; then
        echo ""
        echo "[ERROR] No compatible versions found" >&2
        echo "        未找到兼容版本。" >&2
        echo ""
        echo "[INFO] You need to compile Flutter Engine manually." >&2
        echo "       您需要手动编译 Flutter Engine。" >&2
        echo "       See: https://github.com/krystic/flutter-arm-cjk-fix/blob/main/README.md" >&2
        return 1
    fi
    
    # 检查是否有精确匹配
    local exact_match=""
    local exact_source=""
    while IFS='|' read -r version source is_exact; do
        if [[ "$is_exact" == "true" ]]; then
            exact_match="$version"
            exact_source="$source"
            break
        fi
    done <<< "$all_versions"
    
    local replacement_so=""
    
    if [[ -n "$exact_match" ]]; then
        # 找到精确版本
        echo ""
        echo "[OK] Exact version found: $exact_match"
        echo "     找到精确版本：$exact_match"
        replacement_so="$SO_LIB_DIR/libflutter_linux_gtk.so.$exact_match"
        
        # 如果是线上版本且本地不存在，下载
        if [[ "$exact_source" == "online" && ! -f "$replacement_so" ]]; then
            echo ""
            echo "[INFO] Downloading from GitHub..." >&2
            echo "       正在从 GitHub 下载..." >&2
            replacement_so=$(download_so_file_if_needed "$exact_match")
            if [[ $? -ne 0 || ! -f "$replacement_so" ]]; then
                echo "[ERROR] Failed to download" >&2
                echo "        下载失败。" >&2
                return 1
            fi
        fi
    else
        # 未找到精确版本，显示相似版本供选择
        echo ""
        echo "[WARN] No exact version found for $flutter_version" >&2
        echo "       未找到精确版本 $flutter_version" >&2
        echo ""
        echo "[INFO] Found compatible versions (same major.minor):" >&2
        echo "       找到兼容版本（相同主版本号）：" >&2
        
        
        local version_array=()
        local source_array=()
        while IFS='|' read -r ver source is_exact; do
            if [[ -n "$ver" ]]; then
                version_array+=("$ver")
                source_array+=("$source")
            fi
        done <<< "$all_versions"
        
        if [[ ${#version_array[@]} -eq 0 ]]; then
            echo ""
            echo "[ERROR] No compatible versions found" >&2
            echo "        未找到兼容版本。" >&2
            return 1
        fi
        
        local i
        echo
        for ((i=0; i<${#version_array[@]}; i++)); do
            local source_tag=""
            if [[ "${source_array[$i]}" == "local" ]]; then
                source_tag=" [本地/local]"
            else
                source_tag=" [线上/online]"
            fi
            echo "       [$((i+1))] ${version_array[$i]}${source_tag}" >&2
        done
        echo ""
        echo "Try one of these versions? (select number or 'n' to skip) [1]: "
        read -r -p "尝试这些版本吗？（输入编号或 'n' 跳过）[1]:" choice
        choice=${choice:-1}
        
        if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#version_array[@]} )); then
            local selected_version="${version_array[$((choice-1))]}"
            local selected_source="${source_array[$((choice-1))]}"
            replacement_so="$SO_LIB_DIR/libflutter_linux_gtk.so.$selected_version"
            
            # 如果是线上版本，需要先下载
            if [[ "$selected_source" == "online" && ! -f "$replacement_so" ]]; then
                echo ""
                echo "[INFO] Downloading Flutter Engine $selected_version from GitHub..." >&2
                echo "       正在从 GitHub 下载 Flutter Engine $selected_version..." >&2
                
                replacement_so=$(download_so_file_if_needed "$selected_version")
                if [[ $? -ne 0 || ! -f "$replacement_so" ]]; then
                    echo "[ERROR] Failed to download Flutter Engine $selected_version" >&2
                    echo "        下载失败。" >&2
                    return 1
                fi
            fi
            
            if [[ -f "$replacement_so" ]]; then
                echo ""
                echo "[OK] Using version: $selected_version (instead of $flutter_version)"
                echo "     使用版本：$selected_version（代替 $flutter_version）"
                echo ""
                echo "[WARN] This is not an exact match - test carefully!"
                echo "       这不是精确匹配 - 请仔细测试！"
            else
                echo "[ERROR] SO file not found: $replacement_so" >&2
                return 1
            fi
        else
            echo ""
            echo "[INFO] Skipped. You need to compile Flutter Engine manually." >&2
            echo "       已跳过。您需要手动编译 Flutter Engine。" >&2
            echo "       See: https://github.com/krystic/flutter-arm-cjk-fix/blob/main/README.md" >&2
            return 1
        fi
    fi
    
    # 执行替换（统一处理精确版本和相似版本）
    if [[ -n "$replacement_so" && -f "$replacement_so" ]]; then
        echo ""
        
        # 备份原 SO 文件
        local backup_path="${so_path}.bak"
        if [[ ! -f "$backup_path" ]]; then
            echo "[INFO] Creating backup..."
            echo "       正在创建备份..."
            cp "$so_path" "$backup_path" && chmod -w "$backup_path" || {
                echo "[ERROR] Failed to create backup" >&2
                echo "        备份失败。" >&2
                return 1
            }
            echo "      Backup: $backup_path"
        else
            echo "[INFO] Backup already exists: $backup_path"
            echo "       备份已存在。"
        fi
        echo ""
        
        # 替换 SO 文件
        echo "[INFO] Replacing SO file..."
        echo "       正在替换 SO 文件..."
        cp "$replacement_so" "$so_path" && chmod +x "$so_path" || {
            echo "[ERROR] Failed to replace SO file" >&2
            echo "        替换失败。" >&2
            return 1
        }
        
        echo ""
        echo "[OK] Flutter Engine replaced successfully!"
        echo "     Flutter Engine 已成功替换！"
        echo ""
        echo "[INFO] Original: $backup_path"
        echo "       Replacement: $so_path"
        echo ""
        echo "[INFO] To restore original:"
        echo "       恢复原文件的命令："
        echo "       sudo cp $backup_path $so_path"
        
        return 0
    else
        echo "[ERROR] No SO file available for replacement" >&2
        return 1
    fi
}

# 尝试下载指定版本的 SO 文件（若本地不存在）
download_so_file_if_needed() {
    local flutter_version=$1
    local so_file="$SO_LIB_DIR/libflutter_linux_gtk.so.$flutter_version"

    # 环境变量可禁用自动下载
    if [[ "${FLUTTER_CJK_DISABLE_SO_DOWNLOAD:-0}" == "1" ]]; then
        [[ -f "$so_file" ]] && echo "$so_file" && return 0
        return 1
    fi

    # 已有则直接返回
    if [[ -f "$so_file" ]]; then
        echo "$so_file"
        return 0
    fi

    echo "" >&2
    echo "[INFO] SO file not found locally, checking GitHub repository..." >&2
    echo "       本地未找到 SO 文件，正在检查 GitHub 仓库..." >&2

    local github_so_url="$GITHUB_RAW_BASE/libflutter_linux_gtk.so.$flutter_version"

    echo "[INFO] Checking GitHub for prebuilt SO..." >&2
    echo "       正在检查 GitHub 预编译 SO..." >&2

    if curl -sfI "$github_so_url" >/dev/null 2>&1; then
        mkdir -p "$SO_LIB_DIR"
        echo "[INFO] Starting download from GitHub (30-40MB, shows progress)..." >&2
        echo "       开始从 GitHub 下载（约30-40MB，将显示进度条）..." >&2
        echo "" >&2
        if curl -fL --progress-bar "$github_so_url" -o "$so_file"; then
            chmod +x "$so_file"
            local size=$(du -h "$so_file" | cut -f1)
            echo ""  >&2
            echo "[OK] Downloaded: $(basename "$so_file")" >&2
            echo "     下载完成: $size" >&2
            echo "$so_file"
            return 0
        else
            echo "[ERROR] Failed to download SO file" >&2
            echo "        下载失败。" >&2
            rm -f "$so_file" 2>/dev/null
            return 1
        fi
    else
        echo "[INFO] No prebuilt SO found on GitHub for version $flutter_version" >&2
        echo "       GitHub 上未找到该版本的预编译 SO 文件。" >&2
        return 1
    fi
}

# 查找相似版本的 SO 文件（主版本号匹配）
# 查找所有可用版本（包括精确和相似版本，本地和线上）
find_all_available_versions() {
    local target_version=$1
    
    # 提取主版本号 (major.minor)
    local major_minor=$(echo "$target_version" | grep -oE '^[0-9]+\.[0-9]+')
    
    if [[ -z "$major_minor" ]]; then
        return 1
    fi
    
    local -A version_map
    local found_exact_local=false
    
    # 1. 查找本地所有相关版本（包括精确和相似）
    if [[ -d "$SO_LIB_DIR" ]]; then
        while IFS= read -r so_file; do
            [[ -f "$so_file" ]] || continue
            local version=$(basename "$so_file" | sed 's/libflutter_linux_gtk\.so\.//')
            # 收集所有匹配主版本号的版本
            if [[ "$version" =~ ^${major_minor}\. ]]; then
                version_map["$version"]="local"
                # 检查是否找到精确匹配
                [[ "$version" == "$target_version" ]] && found_exact_local=true
            fi
        done < <(find "$SO_LIB_DIR" -name "libflutter_linux_gtk.so.*" 2>/dev/null)
    fi
    
    # 2. 查询项目 GitHub lib 目录中的所有版本（仅在本地未找到精确版本时）
    if [[ "$found_exact_local" == "false" ]]; then
        echo 
        echo "[INFO] Checking GitHub repository for available versions..." >&2
        echo "       正在检查 GitHub 仓库可用版本..." >&2
        
        # 使用 GitHub API 获取 lib 目录内容
        local github_api_url="https://api.github.com/repos/krystic/flutter-arm-cjk-fix/contents/lib"
        local github_files=$(curl -s "$github_api_url" 2>/dev/null | grep -oP '"name":\s*"libflutter_linux_gtk\.so\.\K[0-9]+\.[0-9]+\.[0-9]+' || true)
        
        if [[ -n "$github_files" ]]; then
            while IFS= read -r version; do
                [[ -z "$version" ]] && continue
                # 收集所有匹配主版本号的版本
                if [[ "$version" =~ ^${major_minor}\. ]]; then
                    # 如果本地已有，保持 local 标记；否则标记为 online
                    if [[ -z "${version_map[$version]}" ]]; then
                        version_map["$version"]="online"
                    fi
                fi
            done <<< "$github_files"
        fi
    fi
    
    # 3. 输出所有版本（带标记），格式: version|source|is_exact
    if [[ ${#version_map[@]} -gt 0 ]]; then
        for version in $(printf '%s\n' "${!version_map[@]}" | sort -V -r); do
            local is_exact="false"
            [[ "$version" == "$target_version" ]] && is_exact="true"
            echo "$version|${version_map[$version]}|$is_exact"
        done
        return 0
    fi
    
    return 1
}

# 向后兼容：查找相似版本（调用新的统一函数）
find_similar_so_versions() {
    local target_version=$1
    find_all_available_versions "$target_version" | while IFS='|' read -r version source is_exact; do
        echo "$version|$source"
    done
}

# 挂载 SO 文件替换
mount_so_replacement() {
    local app=$1
    local so_file=$2
    
    local snap_path="/snap/$app/current"
    [[ ! -d "$snap_path" ]] && return 1
    
    # 确保 SO 文件有执行权限
    [[ -f "$so_file" ]] && chmod +x "$so_file" 2>/dev/null || true
    
    # 查找应用中的 libflutter_linux_gtk.so
    local target_so=$(find -L "$snap_path" -name "libflutter_linux_gtk.so*" | head -n1)
    [[ -z "$target_so" ]] && {
        echo "[ERROR] libflutter_linux_gtk.so not found in app: $app"
        return 1
    }
    
    echo ""
    echo "[INFO] Mounting Flutter Engine replacement..."
    echo "       正在挂载 Flutter 引擎替换文件..."
    echo "       Source: $(basename "$so_file") (size: $(du -h "$so_file" | cut -f1))"
    echo "       Target: $target_so"
    
    # 先卸载可能存在的映射
    umount -l "$target_so" 2>/dev/null || true
    
    # 挂载新的 SO 文件
    if mount --bind "$so_file" "$target_so" 2>/dev/null; then
        echo
        echo "[OK] Mounted successfully"
        echo "     挂载成功。"
        return 0
    else
        echo
        echo "[ERROR] Failed to mount SO file replacement"
        echo "        SO 文件替换挂载失败。"
        return 1
    fi
}

# 卸载 SO 文件替换
unmount_so_replacement() {
    local app=$1
    local unmounted=0
    
    # Try to find and unmount SO mount points for this app
    # Handle both /snap/$app/current and /snap/$app/* paths
    while IFS= read -r mount_point; do
        [[ -z "$mount_point" ]] && continue
        if umount -l "$mount_point" 2>/dev/null; then
            ((unmounted++))
            echo "[OK] [$app] Unmounted: $(basename "$mount_point")"
        fi
    done < <(mount -l 2>/dev/null | grep -E "^/.* on /snap/$app/.*/.*libflutter_linux_gtk\.so" | awk '{print $3}')
    
    if [[ $unmounted -gt 0 ]]; then
        echo "     SO 文件替换已卸载。"
        return 0
    fi
    return 1
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo "[ERROR] This operation requires sudo privileges."
        echo "        此操作需要 sudo 权限。"
        exit 1
    fi
}

# 列出自定义配置文件（排除官方 ubuntu.conf 和系统配置文件）
list_custom_config_files() {
    [[ ! -d "$CUSTOM_FONT_CONFIG_DIR" ]] && return 0
    local official_cfg="$(realpath -m "$CONFIG_FILE" 2>/dev/null || echo "$CONFIG_FILE")"
    local github_map_cfg="$(realpath -m "$GITHUB_REPO_MAP" 2>/dev/null || echo "$GITHUB_REPO_MAP")"
    for cfg in "$CUSTOM_FONT_CONFIG_DIR"/*.conf; do
        [[ ! -f "$cfg" ]] && continue
        local cfg_real="$(realpath -m "$cfg" 2>/dev/null || echo "$cfg")"
        # 跳过官方配置和系统配置
        if [[ -n "$official_cfg" ]] && [[ "$cfg_real" == "$official_cfg" ]]; then
            continue
        fi
        if [[ -n "$github_map_cfg" ]] && [[ "$cfg_real" == "$github_map_cfg" ]]; then
            continue
        fi
        echo "$cfg"
    done
}

# 自动创建或刷新系统级服务（官方与自定义模式都可自动启动）
setup_system_service() {
    local need_write=0
    if [ ! -f "$SERVICE_FILE" ]; then
        need_write=1
    elif ! grep -q "ConditionPathExists=$CONFIG_DIR" "$SERVICE_FILE" 2>/dev/null; then
        need_write=1
    fi
    if [ $need_write -eq 1 ]; then
        echo ""
        echo "[INFO] Creating systemd service..."
        echo "       正在创建系统服务..."
        cat <<EOF > "$SERVICE_FILE"
[Unit]
Description=Flutter Font Auto-Mount Service (System Level)
After=snapd.service
Requires=snapd.service
ConditionPathExists=$CONFIG_DIR

[Service]
Type=oneshot
ExecStartPre=/bin/sleep 3
ExecStart=$SCRIPT_PATH --startup
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
        systemctl daemon-reload 2>/dev/null
        systemctl enable flutter-font-fix.service 2>/dev/null
        echo "[OK] Systemd service enabled."
        echo "     系统服务已启用。"
    fi
}

# 删除 systemd 服务
remove_system_service() {
    if [ -f "$SERVICE_FILE" ]; then
        systemctl disable --now flutter-font-fix.service 2>/dev/null || true
        rm -f "$SERVICE_FILE"
        systemctl daemon-reload 2>/dev/null || true
    fi
}

# 完全卸载脚本和所有配置
do_uninstall() {
    echo "[INFO] Uninstalling flutter-font-fix..."
    echo "       正在卸载"
    
    # 1. 卸载所有挂载和映射
    echo "[*] Unmounting all replacements..."
    echo "    卸载所有挂载和映射..."
    do_unmount_all >/dev/null 2>&1 || true
    
    # 2. 删除 SO 库目录
    if [ -d "$SO_LIB_DIR" ]; then
        echo "[*] Removing SO library directory: $SO_LIB_DIR"
        echo "    删除 SO 库目录"
        rm -rf "$SO_LIB_DIR"
    fi
    
    # 3. 删除配置目录
    if [ -d "$CONFIG_DIR" ]; then
        echo "[*] Removing config directory: $CONFIG_DIR"
        echo "    删除配置目录"
        rm -rf "$CONFIG_DIR"
    fi
    
    # 4. 删除 bash completion 文件
    if [ -f "/etc/bash_completion.d/flutter-font-fix" ]; then
        echo "[*] Removing bash completion: /etc/bash_completion.d/flutter-font-fix"
        echo "    删除 bash 补全文件"
        rm -f "/etc/bash_completion.d/flutter-font-fix"
    fi
    
    # 5. 停止并删除 systemd 服务
    echo "[*] Removing systemd service"
    echo "    删除 systemd 服务"
    remove_system_service
    
    # 6. 删除脚本本身
    echo "[*] Removing script: $SCRIPT_PATH"
    echo "    删除脚本"
    rm -f "$SCRIPT_PATH"
    
    echo "[OK] flutter-font-fix uninstalled completely."
    echo "     flutter-font-fix 已完全卸载。"
}

do_unmount_all() {
    echo ""
    echo "[INFO] Removing all SO replacements and font mappings..."
    echo "       正在移除所有 SO 替换和字体映射..."
    
    if [ -f "$CONFIG_FILE" ]; then
        local apps=()
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            local app
            if [[ "$line" == *"|"* ]]; then
                app="${line%%|*}"
            else
                app="$line"
            fi
            [[ -n "$app" ]] && apps+=("$app")
        done < "$CONFIG_FILE"
        
        for app in "${apps[@]}"; do
            # 卸载 SO 替换（如有）
            unmount_so_replacement "$app" 2>/dev/null || true
            
            # 卸载字体映射
            local SNAP_PATH="/snap/$app/current/"
            local TARGET_DIR=$(find -L "$SNAP_PATH" -name "Ubuntu-R.ttf" -printf '%h\n' 2>/dev/null | head -n 1)
            if [ -n "$TARGET_DIR" ]; then
                for f in "$TARGET_DIR"/Ubuntu-*.ttf; do
                    umount -l "$f" 2>/dev/null
                done
                echo "[OK] [$app] Removed."
                echo "     映射已移除。"
            fi
        done
    else
        echo ""
        echo "[INFO] No apps configured."
        echo "       无已配置的应用。"
    fi

    # 卸载所有自定义字体
    for config_file in $(list_custom_config_files); do
        local app_name=$(basename "$config_file" .conf)
        unmount_custom_fonts_from_config "$app_name" >/dev/null 2>&1 || true
    done
}

do_mount() {
    local app=$1
    local is_startup=$2

    # 检查冲突：是否已有自定义配置
    local custom_conf="$CUSTOM_FONT_CONFIG_DIR/${app}.conf"
    if [[ "$is_startup" == "false" ]] && [[ -f "$custom_conf" ]]; then
        local custom_real="$(realpath -m "$custom_conf" 2>/dev/null || echo "$custom_conf")"
        local official_real="$(realpath -m "$CONFIG_FILE" 2>/dev/null || echo "$CONFIG_FILE")"
        if [[ "$custom_real" != "$official_real" ]]; then
            echo ""
            echo "[WARN] App '$app' already has custom font configuration."
            echo "       应用已有自定义字体配置。"
            echo ""
            echo "Remove custom config and use official mapping? [y/N]"
            read -r -p "移除自定义配置并使用官方映射？[y/N] " choice
            case "$choice" in
                [Yy]*)
                    unmount_custom_fonts_from_config "$app" >/dev/null 2>&1
                    echo "[OK] Custom config removed."
                    echo "     自定义配置已移除。"
                    ;;
                *)
                    echo "[INFO] Operation cancelled."
                    echo "       操作已取消。"
                    return 1
                    ;;
            esac
        fi
    fi

    local snap_path="/snap/$app/current/"
    if [ ! -d "$snap_path" ]; then
        echo "[ERROR] Snap app not found: $app"
        echo "        未找到 Snap 应用。"
        return 1
    fi

    # === 优先尝试 SO 文件替换（根治方案）===
    echo ""
    echo "[INFO] Checking for Flutter Engine SO replacement..."
    echo "       正在检查 Flutter 引擎 SO 替换文件..."
    
    # 使用统一的 SO hash 检测版本
    local flutter_version=$(detect_flutter_version_from_so "$snap_path")
    
    if [[ -n "$flutter_version" ]]; then
        echo "       Detected Flutter version: $flutter_version"
        echo "       检测到 Flutter 版本：$flutter_version"
        echo ""
        
        # 统一查找所有可用版本（精确+相似，本地+线上）
        echo "[INFO] Checking for available SO files..."
        echo "       正在检查可用的 SO 文件..."
        
        local all_versions
        all_versions=$(find_all_available_versions "$flutter_version")
        
        if [[ $? -eq 0 && -n "$all_versions" ]]; then
            # 检查是否有精确匹配
            local exact_match=""
            local exact_source=""
            while IFS='|' read -r version source is_exact; do
                if [[ "$is_exact" == "true" ]]; then
                    exact_match="$version"
                    exact_source="$source"
                    break
                fi
            done <<< "$all_versions"
            
            local so_file=""
            
            if [[ -n "$exact_match" ]]; then
                # 找到精确版本
                echo ""
                echo "[OK] Exact version found: $exact_match"
                echo "     找到精确版本：$exact_match"
                so_file="$SO_LIB_DIR/libflutter_linux_gtk.so.$exact_match"
                
                # 如果是线上版本且本地不存在，下载
                if [[ "$exact_source" == "online" && ! -f "$so_file" ]]; then
                    echo ""
                    echo "[INFO] Downloading from GitHub..." >&2
                    echo "       正在从 GitHub 下载..." >&2
                    so_file=$(download_so_file_if_needed "$exact_match")
                    if [[ $? -ne 0 || ! -f "$so_file" ]]; then
                        echo "[ERROR] Failed to download" >&2
                        echo "        下载失败。" >&2
                        so_file=""
                    fi
                fi
            else
                # -a 模式不使用相似版本，直接跳过
                echo ""
                echo "[WARN] No exact version found for $flutter_version" >&2
                echo "       未找到精确版本 $flutter_version" >&2
            fi
            
            # 如果找到了 SO 文件，执行挂载
            if [[ -n "$so_file" && -f "$so_file" ]]; then
                echo ""
                echo "[INFO] Found matching SO file!"
                echo "       找到匹配的 SO 文件！"
                echo "       SO file: $(basename "$so_file")"
                
                if mount_so_replacement "$app" "$so_file"; then
                    if [[ "$is_startup" == "false" ]]; then
                        mkdir -p "$CONFIG_DIR"
                        # 保存配置：app|so （标记使用 SO 替换）
                        sed -i "/^$app|/d" "$CONFIG_FILE" 2>/dev/null
                        sed -i "/^$app$/d" "$CONFIG_FILE" 2>/dev/null
                        echo "$app|so" >> "$CONFIG_FILE"
                        setup_system_service
                    fi
                    echo ""
                    echo "[OK] [$app] Flutter Engine replaced with $(basename "$so_file")"
                    echo "     Flutter 引擎已替换，字体问题已根治。"
                    return 0
                fi
            fi
        fi
        
        # 未找到任何可用版本
        echo ""
        echo "[WARN] No compatible SO file found for Flutter $flutter_version"
        echo "       未找到 Flutter $flutter_version 的兼容 SO 文件。"
        echo ""
        echo "[INFO] You can compile it yourself following:"
        echo "       您可以按照以下文档自行编译："
        echo "       https://github.com/krystic/flutter-arm-cjk-fix/blob/main/README.md"
        echo ""
    else
        echo ""
        echo "[WARN] Could not detect Flutter version from SO file"
        echo "       无法从 SO 文件检测 Flutter 版本"
    fi
    
    # 没有找到 SO 文件或自动检测失败
    if [[ "$is_startup" == "false" ]]; then
        echo "[INFO] Falling back to font mapping method..."
        echo "       回退到字体映射方法..."
    fi

    # === 字体映射方案（兜底） ===
    local target_dir=$(find -L "$snap_path" -name "Ubuntu-R.ttf" -printf '%h\n' | head -n 1)
    if [ -z "$target_dir" ]; then
        echo "[ERROR] No target font files found in app: $app"
        echo "        未在应用中找到目标字体文件。"
        return 1
    fi

    declare -A map=(
        ["Ubuntu-R.ttf"]="$NOTO_REG"   ["Ubuntu-RI.ttf"]="$NOTO_REG"
        ["Ubuntu-L.ttf"]="$NOTO_LIGHT" ["Ubuntu-LI.ttf"]="$NOTO_LIGHT"
        ["Ubuntu-M.ttf"]="$NOTO_MEDIUM" ["Ubuntu-MI.ttf"]="$NOTO_MEDIUM"
        ["Ubuntu-B.ttf"]="$NOTO_BOLD"  ["Ubuntu-BI.ttf"]="$NOTO_BOLD"
    )

    local mounted_count=0
    for ttf in "${!map[@]}"; do
        if [ -f "$target_dir/$ttf" ]; then
            umount -l "$target_dir/$ttf" 2>/dev/null
            if mount --bind "${map[$ttf]}" "$target_dir/$ttf" 2>/dev/null; then
                ((mounted_count++))
            fi
        fi
    done
    
    if [[ $mounted_count -eq 0 ]]; then
        echo "[ERROR] Failed to mount fonts for: $app"
        echo "        挂载字体失败。"
        return 1
    fi

    if [[ "$is_startup" == "false" ]]; then
        mkdir -p "$CONFIG_DIR"
        # 保存配置：app|font （标记使用字体映射）
        sed -i "/^$app|/d" "$CONFIG_FILE" 2>/dev/null
        sed -i "/^$app$/d" "$CONFIG_FILE" 2>/dev/null
        echo "$app|font" >> "$CONFIG_FILE"
        setup_system_service
    fi
    echo "[OK] [$app] Font mapping applied (workaround)."
    echo "     字体映射已应用（临时方案）。"
}

do_unmount() {
    local app=$1
    local snap_path="/snap/$app/current/"
    
    # 尝试卸载 SO 文件替换
    unmount_so_replacement "$app"
    
    # 尝试卸载字体映射
    local target_dir=$(find -L "$snap_path" -name "Ubuntu-R.ttf" -printf '%h\n' | head -n 1)
    if [ -n "$target_dir" ]; then
        for f in "$target_dir"/Ubuntu-*.ttf; do
            umount -l "$f" 2>/dev/null
        done
    fi
    
    # 删除配置：匹配 app|method（新格式）或 app（旧格式）
    if [ -f "$CONFIG_FILE" ]; then
        sed -i "/^$app|/d; /^$app$/d" "$CONFIG_FILE" 2>/dev/null
    fi
    echo "[OK] [$app] Mapping removed."
    echo "     映射已移除。"
}

install_completion() {
    check_root
    local FILE="/etc/bash_completion.d/flutter-font-fix"
    cat > "$FILE" <<'EOF'
# bash completion for flutter-font-fix
_flutter_font_fix_completion() {
    local cur prev apps
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    case "$prev" in
        -a|--app|-c|--custom)
            if command -v snap >/dev/null 2>&1; then
                apps="$(snap list | awk 'NR>1{print $1}')"
                COMPREPLY=( $(compgen -W "$apps" -- "$cur") )
            fi
            ;;
        -e|--executable)
            # 对本地文件进行补全
            COMPREPLY=( $(compgen -f -- "$cur") )
            ;;
        -r|--remove)
            # 补全已映射的应用
            local config_dir="/etc/flutter-cjk"
            local config_file="$config_dir/ubuntu.conf"
            local mapped_apps=()
            
            # 读取官方配置
            if [[ -f "$config_file" ]]; then
                while IFS= read -r line; do
                    [[ -z "$line" ]] && continue
                    # 提取应用名（去掉 |method 后缀）
                    local app="${line%%|*}"
                    [[ -n "$app" ]] && mapped_apps+=("$app")
                done < "$config_file"
            fi
            
            # 读取自定义配置（排除系统配置文件：ubuntu.conf 和 github-repos.conf）
            if [[ -d "$config_dir" ]]; then
                local official_real="$(realpath -m "$config_file" 2>/dev/null)"
                local github_map="$config_dir/github-repos.conf"
                local github_real="$(realpath -m "$github_map" 2>/dev/null)"
                for cfg in "$config_dir"/*.conf; do
                    [[ ! -f "$cfg" ]] && continue
                    local cfg_real="$(realpath -m "$cfg" 2>/dev/null)"
                    # 跳过官方配置和 GitHub 映射表
                    [[ -n "$official_real" && "$cfg_real" == "$official_real" ]] && continue
                    [[ -n "$github_real" && "$cfg_real" == "$github_real" ]] && continue
                    mapped_apps+=("$(basename "$cfg" .conf)")
                done
            fi
            
            # 去重并转为空格分隔
            if [[ ${#mapped_apps[@]} -gt 0 ]]; then
                local unique_apps="$(printf '%s\n' "${mapped_apps[@]}" | sort -u | tr '\n' ' ')"
                COMPREPLY=( $(compgen -W "$unique_apps" -- "$cur") )
            fi
            ;;
    esac
}
complete -F _flutter_font_fix_completion flutter-font-fix.sh flutter-font-fix
EOF
    echo "[OK] Bash completion installed."
    echo "     补全已安装到：$FILE"
    # 尝试在当前 shell 下生效（如果可能）
    if [ -n "$BASH_VERSION" ] && [[ $- == *i* ]]; then
        . "$FILE" 2>/dev/null || true
        echo "[OK] Completion loaded into current shell."
        echo "     当前 shell 已加载补全。"
        echo ""
        echo "[INFO] Completion will be enabled automatically in new terminals."
        echo "       新终端将自动启用补全。"
    fi

    # 如果通过 sudo 调用，则为原始调用用户提供提示
    if [ -n "$SUDO_USER" ] && [ "$SUDO_USER" != "$(id -un)" ]; then
        USER_HOME=$(getent passwd "$SUDO_USER" | cut -d: -f6)
        echo ""
        echo "[INFO] Installed for user: $SUDO_USER"
        echo "       已为用户安装补全。"
        echo ""
        echo "[INFO] To enable in current terminal, run:"
        echo "       若要在当前终端立即生效，请运行："
        echo "       source $FILE"
    fi
}

prompt_install_completion() {
    # 仅在交互式 shell 中提示；非交互式环境下输出安装建议而不阻塞
    if [[ $- != *i* ]]; then
        echo ""
        echo "[INFO] To enable Tab completion, run:"
        echo "       若要启用 Tab 自动补全，请运行："
        echo "       sudo \"$SCRIPT_PATH\" -i"
        return
    fi

    local reply
    echo "Install Tab completion now? [y/N]"
    read -r -p "现在安装 Tab 自动补全吗？[y/N] " reply
    case "$reply" in
        [Yy]*)
            if [[ $EUID -eq 0 ]]; then
                install_completion
            else
                echo ""
                echo "[INFO] Requires sudo privileges, installing..."
                echo "       需要 sudo 权限，正在安装..."
                sudo "$SCRIPT_PATH" -i
            fi
            ;;
        *)
            echo ""
            echo "[INFO] Installation cancelled."
            echo "       已取消安装。"
            ;;
    esac
}

# 获取 snap 应用的路径
get_snap_app_path() {
    local app=$1
    local snap_path="/snap/$app/current"
    [ -d "$snap_path" ] && echo "$snap_path" && return 0
    return 1
}

# 获取应用内所有 ttf/ttc 字体文件（包括子目录和符号链接）
get_fonts_in_app() {
    local app_path=$1
    find -L "$app_path" -type f \( -iname "*.ttf" -o -iname "*.ttc" \) 2>/dev/null | sort
}

list_mapped_apps() {
    declare -A seen=()
    echo ""
    echo "[INFO] Apps with mappings:"
    echo "       已有映射的应用："

    if [[ -f "$CONFIG_FILE" ]]; then
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            local app
            if [[ "$line" == *"|"* ]]; then
                app="${line%%|*}"
            else
                app="$line"
            fi
            seen["$app"]=1
        done < "$CONFIG_FILE"
    fi

    for cfg in $(list_custom_config_files); do
        local app_name=$(basename "$cfg" .conf)
        seen["$app_name"]=1
    done

    if [[ ${#seen[@]} -eq 0 ]]; then
        echo "  (none) / 无"
        return 0
    fi

    for app in "${!seen[@]}"; do
        echo "  - $app"
    done | sort
}

list_mapped_apps_detail() {
    declare -A has_official=()
    declare -A official_method=()
    declare -A has_custom=()

    if [[ -f "$CONFIG_FILE" ]]; then
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            local app method
            if [[ "$line" == *"|"* ]]; then
                app="${line%%|*}"
                method="${line#*|}"
            else
                # 兼容旧格式（只有应用名）
                app="$line"
                method="unknown"
            fi
            has_official["$app"]=1
            official_method["$app"]="$method"
        done < "$CONFIG_FILE"
    fi

    for cfg in $(list_custom_config_files); do
        local app_name=$(basename "$cfg" .conf)
        has_custom["$app_name"]=1
    done

    declare -A all=()
    for k in "${!has_official[@]}"; do all[$k]=1; done
    for k in "${!has_custom[@]}"; do all[$k]=1; done

    echo ""
    echo "[INFO] Detailed mappings:"
    echo "       详细映射列表："
    if [[ ${#all[@]} -eq 0 ]]; then
        echo "  (none) / 无"
        return 0
    fi

    for app in "${!all[@]}"; do
        local modes=()
        local method_note=""
        
        if [[ -n "${has_official[$app]}" ]]; then
            local method="${official_method[$app]}"
            case "$method" in
                so)
                    method_note=" - SO Engine Replacement (Root Fix) / SO 引擎替换（根治）"
                    ;;
                font)
                    method_note=" - Font Mapping (CJK Workaround) / 字体映射（CJK 临时）"
                    ;;
                unknown)
                    method_note=" - Method Unknown / 方法未知"
                    ;;
            esac
            modes+=("ubuntu/官方")
        fi
        
        [[ -n "${has_custom[$app]}" ]] && modes+=("custom/自定义")
        
        echo "- $app [${modes[*]}]${method_note}"

        if [[ -n "${has_custom[$app]}" ]]; then
            local cfg="$CUSTOM_FONT_CONFIG_DIR/${app}.conf"
            if [[ -f "$cfg" ]]; then
                while IFS= read -r line; do
                    [[ "$line" =~ ^#.*$ ]] && continue
                    [[ -z "$line" ]] && continue
                    local font_path source_path
                    if [[ "$line" == *"|"* ]]; then
                        font_path="${line%%|*}"
                        source_path="${line#*|}"
                    else
                        font_path="$line"; source_path="$NOTO_REG"
                    fi
                    echo "    • $(basename "$font_path")  <=  $(basename "$source_path")"
                done < "$cfg"
            fi
        fi
    done
}

# 判断应用是否在官方修复列表中
app_in_official_config() {
    local app=$1
    # 兼容新格式 (app|method) 和旧格式 (app)
    grep -qE "^$app(\||$)" "$CONFIG_FILE" 2>/dev/null
}

# 卸载自定义字体（从配置文件中读取）
unmount_custom_fonts_from_config() {
    local app=$1
    local config_file="$CUSTOM_FONT_CONFIG_DIR/${app}.conf"

    # 避免误操作官方配置
    if [[ -f "$CONFIG_FILE" ]]; then
        local config_real="$(realpath -m "$config_file" 2>/dev/null || echo "$config_file")"
        local official_real="$(realpath -m "$CONFIG_FILE" 2>/dev/null || echo "$CONFIG_FILE")"
        if [[ "$config_real" == "$official_real" ]]; then
            return 1
        fi
    fi

    [[ ! -f "$config_file" ]] && return 1

    echo ""
    echo "[INFO] Unmounting custom fonts for: $app"
    echo "       正在卸载自定义字体..."

    local count=0
    while IFS= read -r line; do
        [[ "$line" =~ ^#.*$ ]] && continue
        [[ -z "$line" ]] && continue

        local font_path=${line%%|*}
        [[ -z "$font_path" ]] && continue
        if umount -l "$font_path" 2>/dev/null; then
            ((count++))
        fi
    done < "$config_file"

    rm -f "$config_file"

    if [[ $count -gt 0 ]]; then
        echo "[OK] Custom fonts unmounted for: $app"
        echo "     自定义字体已卸载。"
        return 0
    fi
    echo "[WARN] No custom fonts found for: $app"
    echo "      未找到自定义字体。"
    return 1
}

# 统一卸载：官方映射 + 自定义映射
unmount_app() {
    local app=$1
    local found=0

    if app_in_official_config "$app"; then
        do_unmount "$app"
        found=1
    fi

    if unmount_custom_fonts_from_config "$app"; then
        found=1
    fi

    if [[ $found -eq 0 ]]; then
        echo "[WARN] No mappings found for: $app"
        echo "       未在官方或自定义配置中找到该应用。"
        return 1
    fi
    return 0
}

# 交互式选择并保存字体配置
do_custom_fonts() {
    local app=$1
    
    # 检查是否已在官方配置中
    if app_in_official_config "$app"; then
        echo ""
        echo "[WARN] App '$app' is already in official mode."
        echo "       应用已在官方模式中配置。"
        echo ""
        echo "Remove from official config and use custom fonts? [y/N]"
        read -r -p "从官方配置移除并使用自定义字体？[y/N] " choice
        case "$choice" in
            [Yy]*)
                do_unmount "$app"
                echo "[OK] Removed from official config."
                echo "     已从官方配置移除。"
                ;;
            *)
                echo "[INFO] Keeping official config, operation cancelled / 保留官方配置，操作已取消"
                return 1
                ;;
        esac
    fi
    
    local snap_path
    
    snap_path=$(get_snap_app_path "$app") || {
        echo ""
        echo "[ERROR] App not found or not a Snap package: $app"
        echo "        未找到应用或非 Snap 包。"
        return 1
    }
    
    echo ""
    echo "[INFO] Searching for font files in:"
    echo "       $snap_path"
    
    # 收集所有字体文件
    local fonts=()
    while IFS= read -r font_file; do
        fonts+=("$font_file")
    done < <(get_fonts_in_app "$snap_path")
    
    if [[ ${#fonts[@]} -eq 0 ]]; then
        echo ""
        echo "[ERROR] No font files found in app: $app"
        echo "        未在应用中找到字体文件。"
        return 1
    fi
    
    echo ""
    echo "[OK] Found ${#fonts[@]} font file(s):"
    echo "     找到 ${#fonts[@]} 个字体文件："
    echo ""

    # 显示菜单
    local i
    for ((i=0; i<${#fonts[@]}; i++)); do
        local font="${fonts[$i]}"
        local font_name=$(basename "$font")
        echo "  [$((i+1))] $font_name"
    done

    echo ""
    echo "[INFO] Enter font numbers separated by commas (e.g., 1,3,5), or 'a' for all."
    echo "       输入字体编号（逗号分隔，例如 1,3,5），或输入 'a' 选择全部。"
    read -r -p "> " selection

    # 解析选择
    local selected_fonts=()
    if [[ "$selection" == "a" || "$selection" == "A" ]]; then
        selected_fonts=("${fonts[@]}")
    else
        # 用逗号分割
        IFS=',' read -ra nums <<< "$selection"
        for num in "${nums[@]}"; do
            # 去除空格
            num=$(echo "$num" | tr -d ' ')
            if [[ $num =~ ^[0-9]+$ ]] && (( num >= 1 && num <= ${#fonts[@]} )); then
                selected_fonts+=("${fonts[$((num-1))]}")
            fi
        done
    fi

    if [[ ${#selected_fonts[@]} -eq 0 ]]; then
        echo ""
        echo "[WARN] No fonts selected."
        echo "       未选择任何字体。"
        return 1
    fi

    # Noto 目标路径映射
    local noto_map=("$NOTO_REG" "$NOTO_BOLD" "$NOTO_LIGHT" "$NOTO_MEDIUM")
    local noto_names=("Regular/常规" "Bold/粗体" "Light/细体" "Medium/中等")
    
    # 逐个为每个字体选择目标 Noto 字体
    echo ""
    echo "[INFO] Now select target Noto font for each selected font."
    echo "       现在为每个选中的字体选择目标 Noto 字体。"
    echo ""
    
    local pairs=()
    for font in "${selected_fonts[@]}"; do
        local font_name=$(basename "$font")
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Font: $font_name"
        echo "字体：$font_name"
        echo ""
        echo "Choose target Noto font:"
        echo "选择目标 Noto 字体："
        for ((i=0; i<${#noto_map[@]}; i++)); do
            echo "  [$((i+1))] ${noto_names[$i]}"
        done
        echo ""
        
        local choice=""
        while true; do
            read -r -p "Enter number (1-4): " choice
            if [[ "$choice" =~ ^[1-4]$ ]]; then
                break
            else
                echo "[ERROR] Invalid input, please enter 1-4."
                echo "        输入无效，请输入 1-4。"
            fi
        done
        
        local target="${noto_map[$((choice-1))]}"
        pairs+=("$font|$target")
        echo "[OK] $font_name -> ${noto_names[$((choice-1))]}"
        echo ""
    done
    
    # 保存配置
    mkdir -p "$CUSTOM_FONT_CONFIG_DIR"
    local config_file="$CUSTOM_FONT_CONFIG_DIR/${app}.conf"
    {
        echo "# Flutter Font Fix - Custom Font Configuration"
        echo "# App: $app"
        echo "# Generated: $(date)"
        echo ""
        for pair in "${pairs[@]}"; do
            echo "$pair"
        done
    } > "$config_file"

    # 确保系统服务存在，以便自定义模式也能随系统启动自动挂载
    mkdir -p "$CONFIG_DIR"
    setup_system_service
    
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "[OK] Configuration saved."
    echo "     配置已保存到：$config_file"
    echo ""
    echo "[INFO] Font mappings:"
    echo "       字体映射关系："
    for pair in "${pairs[@]}"; do
        local font_path="${pair%%|*}"
        local target_path="${pair#*|}"
        echo "  • $(basename "$font_path") -> $(basename "$target_path")"
    done
    echo ""
    echo "[INFO] Applying custom font mounts..."
    echo "       正在应用自定义字体挂载..."
    if mount_custom_fonts_from_config "$app"; then
        echo "[OK] Custom fonts mounted for: $app"
        echo "     自定义字体已挂载。"
    else
        echo "[WARN] No fonts mounted, please check configuration."
        echo "       未能挂载，请检查配置。"
    fi

    return 0
}

# 从配置文件挂载自定义字体
mount_custom_fonts_from_config() {
    local app=$1
    local config_file="$CUSTOM_FONT_CONFIG_DIR/${app}.conf"
    
    if [[ ! -f "$config_file" ]]; then
        return 1
    fi
    
    echo ""
    echo "[INFO] Loading custom fonts for: $app"
    echo "       正在加载自定义字体..."
    
    local mounted_count=0
    local failed_count=0
    
    while IFS= read -r line; do
        # 跳过注释和空行
        [[ "$line" =~ ^#.*$ ]] && continue
        [[ -z "$line" ]] && continue

        local font_path
        local source_path

        if [[ "$line" == *"|"* ]]; then
            font_path="${line%%|*}"
            source_path="${line#*|}"
        else
            font_path="$line"
            source_path="$NOTO_REG"  # 兼容旧格式，默认映射到 Regular
        fi

        if [[ ! -f "$font_path" ]]; then
            ((failed_count++))
            continue
        fi
        if [[ ! -f "$source_path" ]]; then
            ((failed_count++))
            continue
        fi

        local font_name=$(basename "$font_path")
        if mount --bind "$source_path" "$font_path" 2>/dev/null; then
            ((mounted_count++))
            echo "[OK] Mounted: $font_name -> $(basename "$source_path")"
            echo "     已挂载：$font_name -> $(basename "$source_path")"
        else
            ((failed_count++))
        fi
    done < "$config_file"
    
    [[ $mounted_count -gt 0 ]] && return 0
    return 1
}

# 在 --startup 时遍历所有应用配置并挂载
mount_all_custom_fonts() {
    if [[ ! -d "$CUSTOM_FONT_CONFIG_DIR" ]]; then
        return 0
    fi
    
    echo ""
    echo "[INFO] Loading all custom font configurations..."
    echo "       正在加载所有自定义字体配置..."
    
    local found=0
    for config_file in $(list_custom_config_files); do
        local app_name=$(basename "$config_file" .conf)
        if mount_custom_fonts_from_config "$app_name"; then
            found=1
        fi
    done
    
    if [[ $found -eq 1 ]]; then
        echo "[OK] Custom font loading completed."
        echo "     自定义字体加载完成。"
    fi
    
    return 0
}

# --- 主逻辑 ---

# 显示用法说明
show_usage() {
    echo "Usage:"
    echo "  sudo $(basename "$0") -a <app_name>       Repair Snap app with Flutter Engine or fonts"
    echo "                                            使用引擎修复或字体映射 (Snap 应用)"
    echo "  sudo $(basename "$0") -c <app_name>       Repair with custom fonts / 自定义字体修复"
    echo "  sudo $(basename "$0") -r <app_name>       Remove/unmount mappings / 移除/卸载映射"
    echo "  $(basename "$0") -l | --list              List mapped apps / 列出已映射应用"
    echo "  $(basename "$0") -d | --detail            Detail mappings / 详细映射信息"
    echo "  sudo $(basename "$0") --remove-all        Remove all / 移除全部"
    echo ""
    echo "  sudo $(basename "$0") -e <exe_path>       Repair non-Snap app by executable path"
    echo "                                            通过可执行文件路径修复非 Snap 应用"
    echo ""
    echo "  sudo $(basename "$0") -i | --install-completion  Install completion / 安装补全"
    echo "  sudo $(basename "$0") --install-service          Install systemd service / 安装系统服务"
    echo ""
    echo "  sudo $(basename "$0") --uninstall-service Uninstall systemd service / 卸载系统服务"
    echo "  sudo $(basename "$0") --uninstall         Uninstall completely / 完全卸载"
    echo ""
    echo "Examples / 示例:"
    echo "  $(basename "$0") -a snap-store                    # Snap app"
    echo "  $(basename "$0") -e /usr/bin/rustdesk             # Non-Snap app"
}

# 自动安装补全（如果尚未安装且有 root 权限）
auto_install_completion() {
    local completion_file="/etc/bash_completion.d/flutter-font-fix"
    if [[ ! -f "$completion_file" ]] && [[ $EUID -eq 0 ]]; then
        echo ""
        echo "[INFO] Shell completion not found, installing..."
        echo "       未找到补全脚本，正在安装..."
        install_completion
    fi
}

# 处理系统级命令（--startup, --uninstall, --install-service, --install-completion 等）
handle_system_commands() {
    case "$1" in
        --startup)
            [ ! -f "$CONFIG_FILE" ] && {
                mount_all_custom_fonts
                exit 0
            }
            while IFS= read -r line; do
                [[ -z "$line" ]] && continue
                # 解析格式：app|method 或 app（旧格式）
                app=""
                if [[ "$line" == *"|"* ]]; then
                    app="${line%%|*}"
                else
                    app="$line"
                fi
                if [ -n "$app" ]; then
                    if ! do_mount "$app" "true"; then
                        echo "[WARN] Failed to mount fonts for: $app, skipping."
                        echo "       跳过该应用的字体挂载。"
                    fi
                fi
            done < "$CONFIG_FILE"
            # 也加载并挂载自定义字体配置
            mount_all_custom_fonts
            exit 0
            ;;
        -e|--executable)
            check_root
            if [ -z "$2" ]; then
                echo "用法 / Usage: $0 -e <executable_path_or_name>"
                echo "Example: $0 -e /usr/bin/rustdesk"
                echo "Example: $0 -e rustdesk"
                exit 1
            fi
            
            local exe_path="$2"
            # 如果不是绝对路径，尝试通过 which 查找
            if [[ "$exe_path" != /* ]]; then
                local resolved_path=$(which "$exe_path" 2>/dev/null)
                if [[ -n "$resolved_path" ]]; then
                    echo "[INFO] Resolved '$exe_path' to: $resolved_path"
                    echo "       解析 '$exe_path' 为：$resolved_path"
                    exe_path="$resolved_path"
                else
                    echo "[ERROR] Executable not found: $exe_path" >&2
                    echo "        未找到可执行文件。" >&2
                    exit 1
                fi
            fi
            
            handle_executable_app "$exe_path"
            exit $?
            ;;
        -c|--custom)
            check_root
            if [ -z "$2" ]; then
                echo "用法 / Usage: $0 -c <app_name>"
                exit 1
            fi
            do_custom_fonts "$2"
            exit 0
            ;;
        -l|--list)
            list_mapped_apps
            exit 0
            ;;
        -d|--detail)
            list_mapped_apps_detail
            exit 0
            ;;
        --remove-all)
            check_root
            do_unmount_all
            exit 0
            ;;
        --uninstall-service)
            check_root
            do_unmount_all
            rm -f "$CONFIG_FILE"
            remove_system_service
            echo "[OK] Systemd service uninstalled and config cleared."
            echo "     系统服务已卸载，配置已清理。"
            exit 0
            ;;
        --uninstall)
            check_root
            do_uninstall
            exit 0
            ;;
        --install-service)
            check_root
            setup_system_service
            exit 0
            ;;
        -i|--install-completion)
            check_root
            install_completion
            exit 0
            ;;
        -*)
            # 未知选项
            echo "[ERROR] Unknown option / 未知选项: $1" >&2
            echo ""
            show_usage
            exit 1
            ;;
    esac
}

# 解析全局参数（如 --cdn）

# 解析参数并执行应用级命令
parse_and_execute_command() {
    local COMMAND="mount"
    local APP_NAME=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -r|--remove) COMMAND="unmount"; APP_NAME="$2"; shift 2 ;;
            -a|--app) APP_NAME="$2"; shift 2 ;;
            -l|--list) COMMAND="list"; shift ;;
            -d|--detail) COMMAND="detail"; shift ;;
            -*) 
                echo "[ERROR] Unknown option / 未知选项: $1" >&2
                echo ""
                show_usage
                exit 1
                ;;
            *) APP_NAME="$1"; shift ;;
        esac
    done

    if [ -z "$APP_NAME" ] && [[ "$COMMAND" != "list" && "$COMMAND" != "detail" ]]; then
        show_usage
        prompt_install_completion
        exit 1
    fi

    if [[ "$COMMAND" == "mount" ]]; then
        [ ! -f "$NOTO_REG" ] && apt update && apt install -y fonts-noto-cjk
        if ! do_mount "$APP_NAME" "false"; then
            echo "[ERROR] App not found or no target fonts: $APP_NAME"
            echo "        未找到应用或未找到可替换字体。"
            prompt_install_completion
            exit 1
        fi
    elif [[ "$COMMAND" == "list" ]]; then
        list_mapped_apps
        exit 0
    elif [[ "$COMMAND" == "detail" ]]; then
        list_mapped_apps_detail
        exit 0
    else
        unmount_app "$APP_NAME"
    fi
}

# --- 主入口 ---

# 先从参数中提取 --cdn 全局参数
parse_global_params() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --cdn)
                if [[ -z "$2" ]]; then
                    echo "[ERROR] --cdn requires a prefix argument"
                    echo "        --cdn 需要一个前缀参数"
                    echo ""
                    echo "Usage: $(basename "$0") --cdn <prefix> <command> [args]"
                    echo "Examples:"
                    echo "  $(basename "$0") --cdn https://raw.staticdn.net/ -a snap-store"
                    echo "  $(basename "$0") --cdn https://ghproxy.com/https://raw.githubusercontent.com/ -a snap-store"
                    exit 1
                fi
                RAW_CDN_PREFIX="$2"
                # 从 GITHUB_RAW_BASE 中提取 owner/repo/branch/path 部分并重建
                local repo_path="${GITHUB_RAW_BASE#https://raw.githubusercontent.com/}"
                GITHUB_RAW_BASE="${RAW_CDN_PREFIX}${repo_path}"
                shift 2
                ;;
            *)
                # 不是全局参数，会退出并返回剩余的参数
                break
                ;;
        esac
    done
    # 输出剩余的参数（用于 eval 恢复）
    for arg in "$@"; do
        printf '%s\n' "$arg"
    done
}

# 检查并自动安装补全（非 --startup 和 --install-completion 命令时执行）
if [[ "${1:-}" != "--startup" && "${1:-}" != "-i" && "${1:-}" != "--install-completion" ]]; then
    auto_install_completion
fi

# 先解析全局参数（--cdn 等），然后处理剩余的命令
mapfile -t params < <(parse_global_params "$@")
set -- "${params[@]}"

# 处理系统级命令（直接 exit）
# 包括：--startup, -c, -l, -d, --remove-all, --uninstall-service, --uninstall, --install-service, -i
if [[ $# -gt 0 ]]; then
    handle_system_commands "$@"
fi

# 如果没有参数，显示用法并退出（不需要 root 权限）
if [[ $# -eq 0 ]]; then
    show_usage
    prompt_install_completion
    exit 1
fi

# 到此处说明是交互模式，需要 root 权限
check_root

# 解析参数并执行应用级命令
parse_and_execute_command "$@"
